import * as fs from "fs";
import * as path from "path";

class GenerateAst {
  public static main(args: string[]) {
    if (args.length !== 1) {
      console.log("Usage: generate_ast <output directory>");
      process.exit(64);
    }

    const outputDir = args[0];
    this.defineAst(outputDir, "Expr", [
      "Binary   : Expr left, Token operator, Expr right",
      "Grouping : Expr expression",
      "Literal  : any value",
      "Unary    : Token operator, Expr right",
    ]);
  }

  private static defineAst(
    outputDir: string,
    baseName: string,
    types: string[]
  ) {
    const filePath = path.join(outputDir, `${baseName}.ts`);
    const writer = fs.createWriteStream(filePath, { encoding: "utf-8" });

    writer.write(`// This file was auto-generated by GenerateAst\n\n`);
    writer.write(`abstract class ${baseName} {\n`);

    // Define the visitor interface
    this.defineVisitor(writer, baseName, types);

    // Define the different types of expressions
    types.forEach((type) => {
      const [className, fields] = type.split(":").map((part) => part.trim());
      this.defineType(writer, baseName, className, fields);
    });

    writer.write(`\n  abstract accept<R>(visitor: Visitor<R>): R;\n`);
    writer.write("}\n");

    writer.end();
  }

  private static defineVisitor(
    writer: fs.WriteStream,
    baseName: string,
    types: string[]
  ) {
    writer.write(`  interface Visitor<R> {\n`);
    types.forEach((type) => {
      const typeName = type.split(":")[0].trim();
      writer.write(
        `    visit${typeName}${baseName}(${baseName.toLowerCase()}: ${typeName}): R;\n`
      );
    });
    writer.write("  }\n");
  }

  private static defineType(
    writer: fs.WriteStream,
    baseName: string,
    className: string,
    fieldList: string
  ) {
    writer.write(`  class ${className} extends ${baseName} {\n`);

    // Constructor
    writer.write(`    constructor(${fieldList}) {\n`);

    // Store parameters in fields
    const fields = fieldList.split(", ");
    fields.forEach((field) => {
      const name = field.split(" ")[1];
      writer.write(`      this.${name} = ${name};\n`);
    });
    writer.write("    }\n");

    // Visitor pattern method
    writer.write(`\n    accept<R>(visitor: Visitor<R>): R {\n`);
    writer.write(`      return visitor.visit${className}${baseName}(this);\n`);
    writer.write("    }\n");

    // Fields
    writer.write("\n");
    fields.forEach((field) => {
      writer.write(`    ${field};\n`);
    });

    writer.write("  }\n");
  }
}

// Example usage, you can call this from a command line or other script
GenerateAst.main(process.argv.slice(2));
